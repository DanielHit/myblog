---
title: 软件设计的核心-控制复杂度 
date: 2016-08-05 14:48:30
tags: 编程, 复杂度
categories: 编程
---

最近重读了《代码大全》这本书, 书中包括的内容非常多, 从软件设计, 代码开发,到 团队管理都有涉及,更像是一个软件编程领域的百科全书. <!--more-->但是,对于书中提到的一点印象最为深刻, 其实在 《人月神话》和《卓有成效的程序员》这两本经典的书籍中都有提到, 那就是:

> 
> #### 软件设计与开发的核心就在于 *控制复杂度*
> 

这句话的核心其实包括两个问题:

- 软件开发的本质问题性难题为什么是 复杂度 ？
- 如何可以一定努力的降低我们软件系统的复杂度 ？

#### 杂耍抛球

其中, 书中对于软件设计必须控制复杂度的解释原因, 使用了一个非常 有意思的比喻 - 杂耍抛球, 书中的描述如下:

>    你可以把它想做是一种心理上的杂耍( 边抛边接: 通过轮流抛接使两个或者两个以上的物体同时保持于空中), 程序要求你在空中保持的(精神上的)球越多,你就越可能漏掉其中的某一个, 从而导致设计或者编码上的错误
> ---- 代码大全

当我读到这一段的时候, 感觉这本书的作者真是说出了软件开发者心中的痛啊! 这段话也可以说是整本书的一个核心, 其实《代码大全》这本书的所有部分都是在围绕『如何降低软件开发中的复杂度』这个观点而论述的.

其实, 作者用这种, 杂耍抛球的方式非常形象的比喻了, 我们的大脑（生物结构上）本质的局限性导致的. 曾经美国人有一个非常有名的调查, 人类的大脑短期记忆能够容纳最多的不连续信息数就是7,加而或减二
具体可以参考心理学上被引用最多的一篇论文之一 [*魔数七, 加二或者减二: 人类处理能力的局限性*](http://psychclassics.yorku.ca/Miller/). 而现实问题域中，我们要处理的变量何止是7! 所以我们根本不可能同时让这么多变量一起出现在我们大脑中, 我们大脑的内存其实是非常小的, 这是我们大脑的本质的局限性所导致的.

#### 没有银弹

另外从哲学的角度来说, 柏拉图认为, 任何事物都有 两个属性: **本质属性** 与 **偶然属性**. 通过本质的属性我们可以真正的区分不同事物，但是偶尔的属性并不能. 通过此原则, 我们可以将软件行业遇到的问题也分为两类, 那么软件开发过程中 本质性的 难题是什么?

《人月神话》的作者认为, 软件行业中遇到的非根本问题(偶然属性)都会随着时间发展，技术的提升，会逐步解决. 但是 开发中的根本性问题 - 对于现实复杂世界本质的概念的复杂性是无法降低的. 书中写到:

>    
>   一个软件系统有大量的状态，存在大量不同元素的相互叠加。 这使得软件系统的复杂性以指数的形式增长。而且，这些复杂度是软件系统的根本属性， 而不像数学和物理中那样可以建立简化的模型而忽略复杂的次要因素。
>

《人月神话》中对于本质的复杂性无法避免, 起了一个名词, 日后基本成了这个行业的通用语: 没有银弹. 作者认为, 不要期望通过一种 万能药 能解决软件开发中所遇到的复杂性问题,复杂性不可避免. 所以 当每次一种新的 编程原因/技术框架/开发模式 等出现的时候, 当有些人大喊可以颠覆以前软件开发中的所有问题的时候的时候, 你就要小心了. 心理默默的告诉自己, **没有银弹!** **没有银弹!** **没有银弹！**(重要的事情说三遍)


#### 降熵

其实，软件的复杂度从某种意义上, 用物理学第二定律来理解和加强. 物理学第二定律又叫做,熵定律: 

> 自然过程中，一个孤立系统的总混乱度（即“熵”）不会减小。

换成是软件行业的背景就是, 用《程序员修炼之道》里面的解释就是:

> 软件的熵总是倾向于最大化的，程序员们称之为“软件腐烂”。

如果, 我们的开发过程中, 不要容忍任何『破窗户』，低劣的设计/错误决策/糟糕的代码,发现一个立即解决, 如果留下，他们会扩散，直至让你的整个系统崩溃.

程序员只有在开发过程中,也只有通过不断的外部做功, 不断主动性的思考和重构你的代码, 通过外部系统注入能量,来降低整个软件系统的熵, 是整个软件系统有序的状态.

为此软件开发行业提出了一些列的原则和指导方法, 重构 / 单元测试/ 模块化设计 / KISS原则/ 面向接口编程/ 模式设计/ 分布式系统等等如此, 其实你都会发现, 这些方法和指导原则,根本都是 告诉程序员, 在软件开发的过程中, 通过这些方法降低软件系统整体的复杂度, 以便后期更好的维护与开发. 当软件复杂度可以得到很好的控制，而不是让软件的熵无限的增长, 那么这个软件系统的寿命也就会很长,更容易后期的维护与扩展.

所以, 我们知道:软件开发中的本质难题是 复杂度, 那么我们在之后开发中 应该时刻的主动思考和做功: 如何通过不断的代码重构降低整体的复杂度. 保持我们的代码熵的最小化.

----
最后，让我们的代码 永垂不朽 ！





